# Тема 10. Декораторы и исключения
Отчет по Теме №10 выполнила:
- Кашилова Елизавета Александровна
- ЗПИЭ-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | - | + |
| Задание 2 | - | + |
| Задание 3 | - | + |
| Задание 4 | - | + |
| Задание 5 | - | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### 

```python

```
### Результат.

![Меню]()

## Выводы



## Лабораторная работа №2
### 

```python

```

### Результат

![Меню]()

### Выводы



## Лабораторная работа №3
### 

```python

```

### Результат

![Меню]()

### Выводы


  
## Лабораторная работа №4
### 

```python

```

### Результат

![Меню]()

### Выводы



## Лабораторная работа №5
### 

```python

```

### Результат

![Меню]()

### Выводы



## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор. Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы.

```python
import time


def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f'\nФункция была выполнена за {end_time - start_time} сек.')
        return result

    return wrapper


@timer_decorator
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 400):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')


if __name__ == '__main__':
    fibonacci()
```

### Результат

![Меню](https://github.com/golonr1na/Software_Engineering_python/blob/Тема_10/pictures/s1.png)

### Выводы

Декоратор позволяет изменять поведение функций или методов без изменения их кода напрямую. Декораторы представляют собой функции, которые принимают другую функцию в качестве аргумента и возвращают новую функцию.
  
## Самостоятельная работа №2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла.

Файл 'empty.txt' -
Файл 'notempty.txt' - 

```python
def read_file(filename):
    try:
        file = open(filename, 'r', encoding='utf-8-sig')
        content = file.read()
        if not content:
            raise Exception(f"{filename} пустой")
        print(content)
    except Exception as e:
        print(str(e))


if __name__ == '__main__':
    read_file('empty.txt')
    read_file('notempty.txt')
```

### Результат

![Меню](https://github.com/golonr1na/Software_Engineering_python/blob/Тема_10/pictures/s2.png)

### Выводы

В представленном коде определена функция `read_file`, которая открывает и читает содержимое файла по заданному имени. В функции используется конструкция `try/except` для обработки исключений. Если файл успешно открывается и содержит данные, то его содержимое выводится на экран. Если файл пустой, то возбуждается исключение с сообщением о пустом файле.

В блоке except обрабатывается возникшее исключение, и выводится сообщение об ошибке. Таким образом, если файл пустой, программа будет выводить сообщение `"empty.txt пустой"`. Если файл не пустой или его открытие вызывает другое исключение, то содержимое файла будет выведено на экран.

Таким образом, данный код демонстрирует использование конструкции `try/except` для обработки исключений при работе с файлами, что повышает устойчивость программы к различным ситуациям, таким как пустой файл.
  
## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль.

```python
def sum_num():
    try:
        num = float(input('Введите число:\n'))
        res = num + 2
        return res
    except ValueError:
        return 'Неподходящий тип данных. Ожидалось число.'

print(sum_num())
print(sum_num())
```

  ### Результат

![Меню](https://github.com/golonr1na/Software_Engineering_python/blob/Тема_10/pictures/s3.png)

### Выводы

В данном коде создана функция `sum_num()`, которая запрашивает у пользователя ввод числа, преобразует введённое значение в тип `float`, складывает его с числом 2 и возвращает результат. Если введённое пользователем значение не может быть преобразовано в число (возникает исключение `ValueError`), то функция вернет строку `'Неподходящий тип данных. Ожидалось число.'`.
Дальше дважды вызывается функция `sum_num()` с помощью `print()`. Если пользователь введет числовое значение, то каждый вызов функции вернет сумму введенного числа и числа 2. Если пользователь введет нечисловое значение, то будет выведено сообщение об ошибке.

Таким образом, данная программа демонстрирует использование исключений для обработки возможного некорректного ввода данных.
  
## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.
  
```python
# Определение класса-декоратора my_decorator
class my_decorator:
    # Инициализация метода конструктора с функцией func
    def __init__(self, func):
        self.func = func

    # Определение метода call, который будет вызываться при применении декоратора к функции
    def __call__(self, *args, **kwargs):
        print(f'Декоратор до выполнения функции "{self.func.__name__}"')  # Вывод сообщения перед выполнением функции
        result = self.func(*args, **kwargs)  # Выполнение функции с переданными аргументами
        print(f'Декоратор после выполнения функции "{self.func.__name__}"')  # Вывод сообщения после выполнения функции
        return result


# Декорирование функций addition и multiply с помощью декоратора my_decorator
@my_decorator
def addition(a, b):
    return a + b  # сложение входящих аргуметов


@my_decorator
def multiply(a, b):
    return a * b  # умножение входящих аргуметов


# Запрос у пользователя двух чисел для выполнения операций
x = int(input('Введите первое число: '))
y = int(input('Введите второе число: '))

# Вызов функций addition и multiply с введенными числами в качестве аргументов
print(addition(x, y))
print(multiply(x, y))
```

### Результат

![Меню](https://github.com/golonr1na/Software_Engineering_python/blob/Тема_10/pictures/s4.png)

### Выводы

Данный код демонстрирует создание и использование декоратора в Python.
В начале определяется класс my_decorator, который является декоратором. Он принимает функцию в качестве аргумента при инициализации (`__init__`) и определяет метод `__call__`, который будет выполняться как декоратор при вызове функции.
Декоратор выводит сообщение "Декоратор до выполнения функции" перед вызовом функции и "Декоратор после выполнения функции" после выполнения функции.
Затем две функции `addition` и `multiply` декорируются с помощью `@my_decorator`, что добавляет поведение декоратора к этим функциям.
Пользователю предлагается ввести два числа, которые затем передаются функциям `addition` и `multiply`.
При вызове `addition` и `multiply`, декоратор сначала выводит сообщение о начале выполнения функции, затем вызывает функцию и сохраняет результат, и, наконец, выводит сообщение о завершении выполнения функции.
В итоге, значения, возвращаемые функциями `addition` и `multiply` после обработки декоратором, выводятся на экран.
  
## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.
  
```python
class MyException(Exception):
    pass


# Функция, которая вызывает исключение, если число не положительно
def positive_number(n):
    try:
        if n <= 0:  # Проверка, является ли число положительным
            raise MyException(f'{n} не является положительным числом')
        print(f'Введено положительное число: {n}')  # Вывод положительного числа
    except MyException as e:
        print(f'Поймано исключение: {e}')  # Вывод информации об исключении


# Функция, которая вызывает исключение, если строка не содержит только цифры
def only_letters(s):
    try:
        if not s.isalpha():  # Проверка, содержит ли строка только буквы
            raise MyException(f'{s} содержит не только буквы')
        print(f'Введена строка только из букв: {s}')  # Вывод строки, состоящей только из букв
    except MyException as e:
        print(f'Поймано исключение: {e}')  # Вывод информации об исключении


# Тестирование функций
test_num = int(input('Введите число: '))
positive_number(test_num)
test_string = input('Введите строку: ')
only_letters(test_string)
```

### Результат

![Меню](https://github.com/golonr1na/Software_Engineering_python/blob/Тема_10/pictures/s5.png)

### Выводы

Этот код демонстрирует использование пользовательского исключения `MyException` в функциях `positive_number` и `only_letters`.

В первой функции `positive_number` проверяется, является ли число положительным, и если нет, то вызывается исключение `MyException`. Во второй функции `only_letters` проверяется, содержит ли строка только буквы, и если нет, то также вызывается исключение `MyException`.
Каждая функция обрабатывает это исключение с использованием конструкции `try-except`, где отлавливается и обрабатывается `MyException`, выводя информацию об исключении.

Таким образом, этот код показывает пример использования пользовательских исключений для обработки определенных ситуаций и управления ошибками.
  
## Общие выводы по теме

Декораторы и исключения - это два мощных средства, которые позволяют более гибко управлять выполнением кода и обрабатывать возможные ошибки и исключения.

Декораторы в Python позволяют динамически изменять поведение функций или методов, не изменяя их саму реализацию. Декораторы могут быть использованы для расширения функциональности функций, контроля доступа, логирования, кеширования и многого другого. Они часто применяются для изоляции и выделения специфической функциональности, что делает код более чистым и понятным.

Исключения в Python позволяют обрабатывать ошибочные ситуации и нестандартные сценарии в программах. При возникновении исключения выполнение программы не прерывается, а код может быть написан так, чтобы обработать исключение и продолжить выполнение программы. Python предоставляет множество встроенных исключений, но также позволяет создавать пользовательские исключения, чтобы обрабатывать конкретные ситуации или ошибки.
