# Тема 9. ООП: концепции, принципы и примеры реализации.
Отчет по Теме №9 выполнила:
- Кашилова Елизавета Александровна
- ЗПИЭ-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | - | - |
| Задание 3 | - | - |
| Задание 4 | - | - |
| Задание 5 | - | - |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### 

```python
class Ivan:
    __slots____ = ['name']

    def __init__(self, name):
        if name == 'Иван':
            self.name = f"Дa, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"


person1 = Ivan('Алексей')
person2 = Ivan('Иван')
print(person1.name)
print(person2.name)
person2.surname = 'Петров'
```
### Результат.

![Меню](https://github.com/golonr1na/Software_Engineering_python/blob/Тема_9/pictures/l1.png)

## Выводы

В данном коде создан класс `Ivan`, который имеет атрибут name, ограниченный слотами. В конструкторе `__init__` происходит инициализация объекта класса, при этом если переданное имя равно 'Иван', то атрибут name получает значение `"Дa, я Иван"`, в противном случае значение атрибута будет `"Я не {name}, а Иван"`.
Затем создаются два объекта класса `Ivan: person1` с именем 'Алексей' и `person2` с именем 'Иван'. После чего выводятся значения их атрибута name.
В последней строчке кода происходит попытка добавить атрибут `surname` к объекту `person2`, но так как атрибут `surname` не был указан в слотах класса, будет сгенерировано исключение `AttributeError`.

Таким образом, код иллюстрирует применение слотов в классе для ограничения возможных атрибутов объекта и возможные ошибки при попытке добавления атрибутов, не указанных в слотах.

## Лабораторная работа №2
### 

```python

```

### Результат

![Меню]()

### Выводы



## Лабораторная работа №3
### 

```python

```

### Результат

![Меню]()

### Выводы


  
## Лабораторная работа №4
### 

```python

```

### Результат

![Меню]()

### Выводы



## Лабораторная работа №5
### 

```python

```

### Результат

![Меню]()

### Выводы



## Самостоятельная работа №1
### Задание Садовник и помидоры.<br>Тесты:<br>1) Вызовите справку по садоводству<br>2) Создайте объекты классов TomatoBush и Gardener<br>3) Используя объект класса Gardener, поухаживайте за кустом с помидорами<br>4) Попробуйте собрать урожай, когда томаты еще не дозрели.<br>Продолжайте ухаживать за ними<br>5) Соберите урожай.

```python
class Tomato:
    states = ['отсутствует', 'цветение', 'зеленый', 'красный']

    # Установка начального состояния роста
    def __init__(self, index):
        self._index = index
        self._state = Tomato.states[0]

    # Перевод томата на следующую стандию созревания
    def grow(self):
        self._state = Tomato.states[(Tomato.states.index(self._state) + 1) % len(Tomato.states)]

    def is_ripe(self):
        return self._state == 'красный'


class TomatoBush:
    # Список всех томатов
    def __init__(self, num_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(num_tomatoes)]

    # Рост томатов на кусте
    def grow_all(self):
        for tomato in self.tomatoes:
            tomato.grow()

    # Проверка спелости
    def all_are_ripe(self):
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    # Очищение куста
    def give_away_all(self):
        self.tomatoes = []


class Gardener:
    # Определение свойств имя и растение
    def __init__(self, name, plant):
        self.name = name
        self._plant = plant

    # Уход за садом
    def work(self):
        self._plant.grow_all()
        print(f'{self.name} Позаботился(ась) о растении.')

    # Проверка спелости и сбор урожая. Если все спелые, то сбор урожая
    def harvest(self):
        if self._plant.all_are_ripe():
            print(f'Томаты красные. {self.name} собрал(а) урожай.')
            self._plant.give_away_all()
        else:
            print('Томаты ещё не красные')

    # Статический метод, выводит "справку"
    @staticmethod
    def knowledge_base():
        print('Справка по садоводству')


# Вызов справки по садоводству
Gardener.knowledge_base()

# Создание объектов классов TomatoBush и Gardener
tomato_bush = TomatoBush(int(input('Сколько томатов на кусте?: ')))
gardener = Gardener(input('Ваше имя: '), tomato_bush)

while len(tomato_bush.tomatoes) != 0:
    action = int(input('Выберите действие: 1 - позаботиться о саде; 2 - Попробовать собрать урожай: '))
    if action == 1:
        gardener.work()  # Уход за кустом
    elif action == 2:
        gardener.harvest()  # Сбор урожая
        print()
    else:
        print('Ошибка, значение не предполагает действия')
```

### Результат

![Меню](https://github.com/golonr1na/Software_Engineering_python/blob/Тема_9/pictures/s1.png)

### Выводы

Это задание помогает получить базовое понимание объектно-ориентированного программирования (ООП), особенно в контексте классов и методов. Оно также иллюстрирует концепцию состояния объекта, которое может изменяться с течением времени, и как это может влиять на поведение и функциональность объекта.

## Общие выводы по теме
В данной теме мы рассмотрели как ООП позволяет организовать код, создавая классы, которые представляют объекты и их поведение.

Классы: Классы представляют собой основу ООП в Python. Они используются для создания новых типов данных, которые могут содержать атрибуты (переменные) и методы (функции).
Объекты: Объекты являются конкретными экземплярами классов. Каждый объект обладает своим собственным состоянием (атрибутами) и поведением (методами).
Наследование: Наследование позволяет создавать новые классы на основе уже существующих классов. Подклассы могут наследовать атрибуты и методы родительских классов, а также добавлять собственные.
Инкапсуляция: Инкапсуляция обеспечивает защиту данных объекта от прямого доступа. С помощью атрибутов и методов, определенных как приватные, можно скрыть внутренние детали реализации.
Полиморфизм: Полиморфизм позволяет объектам разных классов обладать одинаковым интерфейсом, что упрощает работу с объектами различных типов данных.
